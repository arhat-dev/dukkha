bootstrap:
  shell: ${SHELL}

# shell command to provision a shell to execute your scripts
shell:
# fist shell will become the default shell, you can reference it using `shell`,
# but other shells with `shell:<shell_name>`
- name: bash
  # environment variables used when provisioning a shell
  env:
  - SHELL_ENV_NAME=value
  cmd:
  - bash
  - -x
  - -c
- name: python
  cmd@shell: |-
    echo "- $(command -v python3)"

tools:
  # configure tools
  <tool_kind>:
  # fisrt configuration will become the default shell
  # empty value is also valid
  - name: <tool_kind>
    # environment variables applied when running this tool
    env:
    - ENV_VAR_NAME=value
    - ENV_VAR_FOO=${ENV_VAR_NAME}
    - ENV_VAR_BAR=$ENV_VAR_FOO
    - ENV_VAR_EXP=$(shell expression)
    # cmd to run this tool
    cmd:
    - <path to the tool>
    - -f
    - some value
    - --bar

<tool_kind>{:<tool_name>}:<task_kind>:
- name: <task_name>
  # you cannot run the same task in the hook
  hook:
    before:
    # use the default shell to run commands
    - shell: |-
        echo "foo"
    # use a specific shell to run commands
    - shell:<shell_name>: |-
        print("bar")

    # run another predefined task
    - task: <tool_kind>{:<tool_name>}:<task_kind>:<another_task_name>

    # run commands/tasks after a successful task execution
    after:success:
    - task: <tool_kind>{:<tool_name>}:<task_kind>:<another_task_name>
    - shell: echo "Done."

    # run commands/tasks when the task execution failed
    after:failure:
    - task: <tool_kind>{:<tool_name>}:<task_kind>:<another_task_name>
    - shell: echo "Failed."

- name: <another_task_name>
  # you can have nested rendering options
  hook@shell: |-
    cat <<EOF
    before@template: |-
      {{- if .FOO -}}
      - shell: echo "foo"
      {{- end -}}
    after:success@shell: |-
      printf "- shell: echo 'Success.'"
    EOF
